function collectLeafValues(obj, startSymbol) {
  let values = [];

  function traverse(o) {
    if (o && typeof o === 'object') {
      if (Array.isArray(o)) {
        o.forEach((item) => traverse(item));
      } else {
        Object.values(o).forEach((value) => traverse(value));
      }
    } else {
      values.push(String(o));
    }
  }

  traverse(obj);
  return {
    word: values.join(''),
    ...(obj[startSymbol] !== undefined && { parseTree: obj }),
  };
}

export default function Parse(word, cfg1) {
  const cfg = cfg1.reduceToChomskyNormalForm();

  const wordTable = new Array(word.length);

  for (let i = 0; i < wordTable.length; i++)
    wordTable[i] = new Array(i + 1).fill([]);

  Array.from(word).forEach((symbol, index) => {
    cfg.getNonTerminals().forEach((nonTerminal) => {
      if (
        cfg
          .getProductions()
          [nonTerminal].some((production) => production.includes(symbol))
      )
        wordTable[wordTable.length - 1][index] = [
          ...wordTable[wordTable.length - 1][index],
          nonTerminal,
        ];
    });
  });

  for (let i = wordTable.length - 1; i >= 1; i--) {
    for (let j = 0; j < i; j++) {
      let t = 0;
      for (let k = i; k < wordTable.length; k++) {
        wordTable[k][j].forEach((symbol1) => {
          wordTable[wordTable.length - 1 - t][j + wordTable.length - k].forEach(
            (symbol2) => {
              cfg.getNonTerminals().forEach((nonTerminal) => {
                cfg.getProductions()[nonTerminal].some((production) => {
                  if (
                    production.length === 2 &&
                    production[0] === symbol1 &&
                    production[1] === symbol2
                  )
                    wordTable[i - 1][j] = [
                      ...new Set([...wordTable[i - 1][j], nonTerminal]),
                    ];
                });
              });
            }
          );
        });
        t++;
      }
    }
  }

  function wordIsGeneratedByGrammar() {
    return wordTable[0][0].includes(cfg.getStartSymbol());
  }

  function getGenerativeTree() {
    const levels = [];

    if (!wordIsGeneratedByGrammar())
      throw { message: 'Word is not generated by grammar!' };

    const baseProductions = {};
    for (const production in cfg.getProductions()) {
      baseProductions[production] = cfg
        .getProductions()
        [production].filter((production1) => production1.length === 1)
        .flat();
      if (baseProductions[production].length === 0)
        delete baseProductions[production];
    }

    levels.push(
      Object.entries(baseProductions).flatMap(([key, values]) =>
        values.map((value) => ({ [key]: value }))
      )
    );

    const prods = cfg.getProductions();

    for (let i = 1; i < word.length; i++) {
      const nonTerms = [...new Set(wordTable[wordTable.length - i - 1].flat())];
      levels.unshift([]);

      let t = 0;
      for (let j = 0; j < i; j++) {
        nonTerms.forEach((nonTerminal) => {
          prods[nonTerminal].forEach((production) => {
            if (production.length === 2) {
              levels[levels.length - i + t].forEach((production1) => {
                levels[levels.length - j - 1].forEach((production2) => {
                  if (
                    Object.keys(production1)[0] === production[0] &&
                    Object.keys(production2)[0] === production[1]
                  ) {
                    levels[levels.length - i - 1].push({
                      [nonTerminal]: [
                        {
                          [Object.keys(production1)[0]]:
                            Object.values(production1)[0],
                        },
                        {
                          [Object.keys(production2)[0]]:
                            Object.values(production2)[0],
                        },
                      ],
                    });
                  }
                });
              });
            }
          });
        });
        t++;
      }
    }

    return levels[0]
      .map((production) => collectLeafValues(production, cfg.getStartSymbol()))
      .filter(
        (production) =>
          production.word === word && production.parseTree !== undefined
      )
      .map((production) => {
        return {
          parseTree: production.parseTree,
        };
      });
  }

  return {
    getGenerativeTree,
    wordIsGeneratedByGrammar,
  };
}
